"use strict";

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _request = require("request");

var _request2 = _interopRequireDefault(_request);

var _neo4jParser = require("neo4j-parser");

var _neo4jParser2 = _interopRequireDefault(_neo4jParser);

var _neo4jQueryObject = require("neo4j-query-object");

var _neo4jQueryObject2 = _interopRequireDefault(_neo4jQueryObject);

var _cypherTools = require("cypher-tools");

var _cypherTools2 = _interopRequireDefault(_cypherTools);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module simple-neo4j
 * @requires {@link https://www.npmjs.com/package/babel-polyfill|babel-polyfill}
 * @requires {@link https://www.npmjs.com/package/request|request}
 * @requires {@link https://www.npmjs.com/package/lodash|lodash}
 * @requires {@link https://www.npmjs.com/package/neo4j-parser|neo4j-parser}
 * @requires {@link https://www.npmjs.com/package/neo4j-query-object|neo4j-query-object}
 * @requires {@link https://www.npmjs.com/package/cypher-tools|cypher-tools}
 */

/**
 * Object to configure class properties and do other stuff related to class
 * configuration or construction
 *
 * @typedef {object} module:simple-neo4j~propertyConfigObj
 * @property {boolean} [raw=false] -
 * Raw/Unparse mode for all transactions
 * @property {array} [transactionQueue=[]] -
 * Transactions waiting to be processed, don't set this unless you know what
 * your doing. theres normally no need to ever set this.
 * @property {object} [queryQueue={}] -
 * Queries waiting to be converted to a transaction, don't set this unless you know what
 * your doing. theres normally no need to ever set this.
 * @property {string} [url="http://localhost:7474"] -
 * Database url
 * @property {string} [username="neo4j"] -
 * Database username
 * @property {string} [password="neo4j"] -
 * Database password
 * @property {array} [transaction=[]] -
 * Current transaction to be committed, don't set this unless you know what
 * your doing. theres normally no need to ever set this.
 * @property {function} [QueryObjectClass=neo4j-query-object] -
 * Set a different class to be used for query object instances. It must either
 * be the neo4j-query-object itself or a subclass of it. Don't set this unless
 * you know what your doing. theres normally no need to ever set this.
 */

/**
 * Creates an instance of this class in preperation for use. One instance is
 * all thats needed for all communication.
 *
 * @class module:simple-neo4j
 * @classdesc
 * Provide one or more cypher queries and then commit all queries at one time
 * in a single transaction.
 *
 * This class has a sophisticated parser for the database response, its enabled
 * by default, but can be turned off globally, per transaction, or per query
 * easily. The parser doesn't take up much time and straightens out the parsed
 * response into a pretty and native JavaScript object so its highly suggested
 * to keep on.
 *
 * Since all queries are sent in a single transaction at one time, if an error
 * occurs in one of the queries, all queries are rolled back and the transaction
 * is canceled. This happens in the database, not here, and is a good thing but
 * something to keep in mind if several unrelated queries are sent and one raises
 * an error.
 *
 * @summary
 * Creates an instance of this class
 * @param  {module:simple-neo4j~propertyConfigObj} [opts={}] -
 * Properties configuration object
 * @author {@link http://codepen.io/wiseguy12851|John Mothershed}
 * @copyright 2015 John Mothershed
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0|Apache-2.0}
 * @version 4.0.0
 * @example
 * // Create a new instance
 * new simple-neo4j()
 */
/*
    Copyright 2015 John Mothershed

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 */

module.exports = (function () {
    function SimpleNeo4J() {
        var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
        (0, _classCallCheck3.default)(this, SimpleNeo4J);

        // Set to empty object if not a proper object
        var _opts = opts;
        if (typeof _opts !== "object" || _opts === null) _opts = {};

        // Set all properties to their default value unless specified otherwise
        // in the object
        this.update(_opts, true);
    }

    /**
     * Update one or more class properties by passing in new values in config
     * object. If reset is true then for all properties not specified in object
     * set them to their default value
     *
     * @public
     * @instance
     * @method update
     * @param  {module:simple-neo4j~propertyConfigObj} [opts={}] -
     * Properties configuration object
     * @param {boolean} [reset=false] -
     * Switch from update to set, all properties not in the configuration object
     * will be set to their default value rather than only updating named
     * properties.
     * @summary
     * Update one or more class properties
     * @since 4.0.0
     * @return {undefined}
     * @example
     * // Update raw mode and the username
     * this.update({
     *     raw: true,
     *     username: "new username"
     * });
     */

    (0, _createClass3.default)(SimpleNeo4J, [{
        key: "update",
        value: function update(opts) {
            var reset = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

            var _opts = opts;
            if (typeof _opts !== "object" || _opts === null) return;

            if (_opts.raw || reset) this.raw = _opts.raw;

            if (_opts.transactionQueue || reset) this.transactionQueue = _opts.transactionQueue;

            if (_opts.queryQueue || reset) this.queryQueue = _opts.queryQueue;

            if (_opts.url || reset) this.url = _opts.url;

            if (_opts.username || reset) this.username = _opts.username;

            if (_opts.password || reset) this.password = _opts.password;

            if (_opts.transaction || reset) this.transaction = _opts.transaction;

            if (_opts.QueryObjectClass || reset) this.QueryObjectClass = _opts.QueryObjectClass;
        }

        /**
         * Global raw mode, enable raw unparse mode for the entire class instance
         * until this is unset. While set no parsing will happen and all queries
         * and transactions will be unparsed.
         *
         * @public
         * @instance
         * @member raw
         * @summary
         * Global raw mode for this instance
         * @type {boolean}
         * @default false
         * @since 3.1.0
         */

    }, {
        key: "nextInQueue",

        /**
         * Attempt to commit the next transaction queue, if a transaction is already
         * being committed then calling this methid will do nothing. If a new queue
         * item is added and the current queue is empty, in other word, the queue
         * system is waiting to be started again. Then this will begin processing
         * queues again.
         *
         * @protected
         * @instance
         * @method nextInQueue
         * @summary
         * Attempt to commit the next transaction queue
         * @since 4.0.0
         * @return {undefined}
         */
        value: function nextInQueue() {
            // Skip this method if the transaction queue is empty or the commit queue is
            // not yet empty
            if (this.transaction.length > 0 || this.transactionQueue.length < 1) return;

            var transaction = undefined;

            // Pull a valid transaction from the queue, a valid transaction is an
            // array with a length of 2 or more since the first item is raw mode.
            // Keep going through until a valid transaction is found or until all
            // have been gone through in which case exit early
            // Hopefull all are valid but this is just a general safeguard
            while (true) {
                transaction = this.transactionQueue.shift();
                if (Array.isArray(transaction) && transaction.length > 1) break;else if (this.transactionQueue.length < 1) return;
            }

            var raw = false;

            // The transaction contains queries of the original commit, the first
            // element is always raw mode
            for (var i = 0; i < transaction.length; i++) {
                if (i === 0) {
                    // Pull raw, it must be a boolean or false will be used
                    raw = transaction[i];
                    if (typeof raw !== "boolean") raw = false;
                    continue;
                }

                // Add only valid query objects to the activeQueue
                if (!(transaction[i] instanceof _neo4jQueryObject2.default)) continue;
                if (transaction[i].query.length < 1) continue;

                this.transaction.push(transaction[i]);
            }

            // Perform the commit for the next transaction in queue
            this.send(raw);
        }

        /**
         * This method is great for when your adding query objects not all at once.
         * Queries are added to a special queue, when your done adding queries make
         * sure to run commit which will convert the queries to a transaction and
         * queue it up for transmission to the database.
         *
         * This method returns a promise that will be fulfilled or rejected once
         * the response is parsed from the database for this query.
         *
         * Provide an object, string, or array of objects and/or strings to be
         * added. It will return with a single promise. If an invalid configuration
         * was given it will return no promise.
         *
         * @public
         * @instance
         * @method addQuery
         * @summary Add a query to a queue in preperation for committing
         * @since 1.0.0
         * @param {module:neo4j-query-object~queryConfigObj|string|array} opts -
         * Options to pass to query(s) for configuration
         * @param {string} [queueName="default"] -
         * Which queue to store this query in, a named queue is like a named
         * transaction. When committing, be sure to specify queue name unless your
         * using the default queue.
         * @return {Promise|undefined}
         * A promise, Promise from Promise.all, or undefined depending on what was
         * given to the method and what was not accepted, if any, for being invalid.
         * @example
         * // Commit a single query to the database
         * let query = `return "Hello"`
         * this.addQuery(query).then(function(resultObj)
         * {
         *     console.log(resultObj.firstValue)
         * });
         *
         * this.commit();
         *
         * // Logs
         * // "Hello"
         */

    }, {
        key: "addQuery",
        value: function addQuery(opts) {
            var queueName = arguments.length <= 1 || arguments[1] === undefined ? "default" : arguments[1];

            // Breakdown opts to valid query object instances
            // If it fails to breakdown any of the objects it will return
            // an empty array, check for that
            var queryObjs = this.processQueries(opts);
            if (queryObjs.length < 1) return;

            // Now check that the queue name is valid, if it is initialize it with
            // an empty array if empty
            var _queueName = queueName;
            if (typeof _queueName !== "string" || _queueName.length < 1) _queueName = "default";

            if (!Array.isArray(this.queryQueue[_queueName])) this.queryQueue[_queueName] = [];

            // Prepare Promise Array
            var promises = [];

            // Go through each option
            for (var i = 0; i < queryObjs.length; i++) {
                var queryObj = queryObjs[i];

                this.queryQueue[_queueName].push(queryObj);
                promises.push(queryObj.promise);
            }

            if (promises.length === 0) return;else if (promises.length === 1) return promises[0];

            return _promise2.default.all(promises);
        }

        /**
         * Goes through one or more query configuration strings, objects, or arrays
         * of strings and/or objects, breaks them down and processes them into
         * QueryObject instances, then returns the valid data of what was passed in
         * as an array of QueryObject instances.
         *
         * @public
         * @static
         * @method processQueries
         * @summary Converts query object config to instances
         * @since 4.1.0
         * @param {module:neo4j-query-object~queryConfigObj|string|array} opts -
         * Query configuration to convert to instances
         * @return {array}
         * Array containing instances of the valid data that was passed in, if no
         * valid data was found then an empty array will be returned.
         */

    }, {
        key: "processQueries",
        value: function processQueries(opts) {
            // opts is required, must be a valid object, string, or array of objects
            // or strings, and must minimally contain a query if an object
            if (typeof opts !== "object" && typeof opts !== "string" && !Array.isArray(opts) || opts === null) return [];

            // Prepare Opts Array
            var _opts = [];
            var queryObjs = [];

            // Add opts to array if not array, otherwise merge into array
            if (!Array.isArray(opts)) _opts.push(opts);else _opts = _opts.concat(opts);

            // Go through each option
            for (var i = 0; i < _opts.length; i++) {
                var opt = _opts[i];

                // Each option must either be a string or a configuration object
                // If its a string fix it to a minimal configuration object
                if (typeof opt === "string" && opt.length > 0) opt = {
                    query: opt
                };

                // The configuration object must be valid and contain at least
                // the query property
                if (typeof opt !== "object" || opt === null || typeof opt.query !== "string" || opt.query.length < 1) continue;

                // By now we have a valid object
                // Add it to the list of queries to execute in this transaction
                queryObjs.push(new this.QueryObjectClass(opt));
            }

            return queryObjs;
        }

        /**
         * When an error occurs the transaction is rolled back and one or more
         * errors are issued. Theres no way to identify which query in the
         * transaction caused the error and there could be non-query errors such
         * as communication or software errors. To make things simple, this method
         * rejects all promises with the error from wherever the error came from
         * during commiting the transaction.
         *
         * @private
         * @instance
         * @method reportErrors
         * @summary
         * Rejects all promises with the provided error
         * @since 1.0.0
         * @param  {any} error -
         * The error to report, has no format
         * @return {undefined}
         * @example
         * // Report error to all callbacks and wipe callbacks
         * this.reportErrors("Oh no!");
         * this.resetOutput();
         */

    }, {
        key: "reportErrors",
        value: function reportErrors(error) {
            // Reject all promises to all queries
            for (var i = 0; i < this.transaction.length; i++) {
                var queryObj = this.transaction[i];
                queryObj.issuePromise(error);
            }
        }

        /**
         * This method is great if your wanting to execute one or more queries
         * right now without a 2-step process. Provide an object, string, or
         * array of objects and/or strings to be processed on the spot and committed
         * to the database in one go.
         *
         * Like addQuery, this also returns a single promise
         *
         * @public
         * @instance
         * @method execute
         * @summary
         * Execute one or more queries right now
         * @since 4.0.0
         * @param {module:neo4j-query-object~queryConfigObj|array|string} opts -
         * Query(s) to pass to the database
         * @param {boolean} [raw=false] -
         * Disable parsing of response
         * @return {Promise|undefined}
         * @example
         * // Immidiately execute a query
         * this.execute("match (a) return a").then(function(resultObj)
         * {
         *     console.log(resultObj.queryObj.query);
         *     // "match (a) return a"
         * });
         */

    }, {
        key: "execute",
        value: function execute(opts) {
            var raw = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

            // Breakdown opts to valid query object instances
            // If it fails to breakdown any of the objects it will return
            // an empty array, check for that
            var queryObjs = this.processQueries(opts);
            if (queryObjs.length < 1) return;

            // Prepare Promise Array
            var promises = [];

            // Prepare transaction for transactionQueue
            var transaction = [];
            transaction.push(raw);

            // Go through each queryObj
            for (var i = 0; i < queryObjs.length; i++) {
                var queryObj = queryObjs[i];

                transaction.push(queryObj);
                promises.push(queryObj.promise);
            }

            this.transactionQueue.push(transaction);

            // Try to activate next queue item, if a queue is still processing this
            // will do nothing but when the current queue finishes it will activate
            // the next anyways
            this.nextInQueue();

            // Return a promise all which works perfectly for this case.
            // If an error occurs all the queries are invalidated anyways and all
            // promises get the same error. If an error doesn't happen then the
            // promise all delivers all the result objects.

            if (promises.length === 0) return;else if (promises.length === 1) return promises[0];

            return _promise2.default.all(promises);
        }

        /**
         * This method sends the transaction queue to the database
         *
         * @public
         * @instance
         * @method commit
         * @summary
         * Sends current transaction queue to the database
         * @since 1.0.0
         * @param {boolean} [raw=false] -
         * Don't parse the response
         * @param {string} [queryQueueName="default"] -
         * Commit the query queue name / buffered transaction name
         * @return {undefined}
         * @example
         * // Report error to all callbacks and wipe callbacks
         * this.addQuery("match (a) return a");
         * this.commit();
         */

    }, {
        key: "commit",
        value: function commit() {
            var raw = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
            var queryQueueName = arguments.length <= 1 || arguments[1] === undefined ? "default" : arguments[1];

            var _queueName = queryQueueName;
            if (typeof _queueName !== "string" || _queueName.length < 1) _queueName = "default";

            if (!Array.isArray(this.queryQueue[_queueName])) return;

            var transaction = [];
            transaction.push(raw);

            for (var i = 0; i < this.queryQueue[_queueName].length; i++) {
                var queryItem = this.queryQueue[_queueName][i];

                // Only valid and filled queries will be added to the transaction
                if (!(queryItem instanceof _neo4jQueryObject2.default) || queryItem.query.length < 1) continue;

                transaction.push(queryItem);
            }

            this.queryQueue[_queueName] = [];
            this.transactionQueue.push(transaction);
            this.nextInQueue();
        }

        /**
         * This method sends the current transaction queue to the database and
         * should never be called.
         *
         * @private
         * @instance
         * @method send
         * @summary
         * Sends current transaction queue to the database
         * @since 1.0.0
         * @param {boolean} [raw=false] -
         * Don't parse the response
         * @return {undefined}
         */

    }, {
        key: "send",
        value: function send() {
            var _this = this;

            var raw = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

            var _raw = raw;
            if (typeof _raw !== "boolean") _raw = false;

            var output = {
                statements: []
            };

            // Prepare for transmission to db by copying relevant information from
            // all the query objects to output object for transmission to db
            for (var i = 0; i < this.transaction.length; i++) {
                var query = this.transaction[i];

                output.statements.push({
                    statement: query.query,
                    parameters: query.parameters
                });
            }

            // JSON-ify the entire output object
            output = (0, _stringify2.default)(output);

            // Send the transaction to the database for committing
            (0, _request2.default)({
                url: this.url + "/db/data/transaction/commit",
                method: "post",
                headers: {
                    "Accept": "application/json; charset=UTF-8",
                    "Content-Type": "application/json"
                },
                auth: {
                    user: this.username,
                    pass: this.password
                },
                body: output
            }, function (error, response, body) {
                // First check for commnication errors to the db, not in the db
                if (error) {
                    // Report and quit
                    _this.reportErrors(error);
                    _this.transaction = [];
                    return;
                }

                /*
                 * By this point everythings in the clear, communication happened
                 * fine. Begin parsing result.
                 */

                (0, _neo4jParser2.default)({
                    body: body,
                    cb: function cb(err, index, resultObj) {
                        if (err) {
                            // Report and quit
                            _this.reportErrors(err);
                            return;
                        }

                        // Get associated query object, ensure that it exists
                        // and a class instance of QueryObj
                        var queryObj = _this.transaction[index];
                        if (!(queryObj instanceof _neo4jQueryObject2.default)) return;

                        queryObj.issuePromise(undefined, resultObj);
                    },
                    raw: _this.raw || _raw,
                    isRaw: function isRaw(index) {
                        var queryObj = _this.transaction[index];

                        // Get associated query object, ensure that it exists
                        // and a class instance of QueryObj
                        if (!(queryObj instanceof _neo4jQueryObject2.default)) return;

                        return queryObj.raw;
                    }
                });

                // Clear out this transaction which will load the next if there
                // is one
                _this.transaction = [];
            });
        }
    }, {
        key: "raw",
        get: function get() {
            return this._raw;
        },
        set: function set(value) {
            if (typeof value === "boolean") this._raw = value;else this._raw = false;
        }

        /**
         * Transaction commit queue in to prevent overlap or stack-up
         *
         * @private
         * @instance
         * @member transactionQueue
         * @summary
         * Transaction queue for transactions waiting to process
         * @type {object}
         * @default {}
         * @since 4.0.0
         */

    }, {
        key: "transactionQueue",
        get: function get() {
            return this._transactionQueue;
        },
        set: function set(value) {
            if (Array.isArray(value)) this._transactionQueue = value;else this._transactionQueue = [];
        }

        /**
         * Query queue for queries waiting to be converted to a transaction
         *
         * @private
         * @instance
         * @member queryQueue
         * @type {object}
         * @default {}
         * @since 4.0.0
         */

    }, {
        key: "queryQueue",
        get: function get() {
            return this._queryQueue;
        },
        set: function set(value) {
            if (typeof value === "object" && value !== null) this._queryQueue = value;else this._queryQueue = {};
        }

        /**
         * Database URL
         *
         * @public
         * @instance
         * @member url
         * @type {string}
         * @default "http://localhost:7474"
         * @since 1.0.0
         */

    }, {
        key: "url",
        get: function get() {
            return this._url;
        },
        set: function set(value) {
            // Match against http[s]://<url here>:<port here>
            var urlTest = /^http[s]?\:\/\/.*?\:[1-9][0-9]*$/;

            if (typeof value === "string" && value.length > 0 && urlTest.test(value)) this._url = value;else this._url = "http://localhost:7474";
        }

        /**
         * Database Username
         *
         * @public
         * @instance
         * @member username
         * @type {string}
         * @default "neo4j"
         * @since 1.0.0
         */

    }, {
        key: "username",
        get: function get() {
            return this._username;
        },
        set: function set(value) {
            if (typeof value === "string" && value.length > 0) this._username = value;else this._username = "neo4j";
        }

        /**
         * Database Password
         *
         * @public
         * @instance
         * @member password
         * @type {string}
         * @default "neo4j"
         * @since 1.0.0
         */

    }, {
        key: "password",
        get: function get() {
            return this._password;
        },
        set: function set(value) {
            if (typeof value === "string" && value.length > 0) this._password = value;else this._password = "neo4j";
        }

        /**
         * An array of queries to transmit to the database, each element contains
         * the actual query, parameters, and callback among other data and information.
         *
         * This is the active queue, it holds the current transaction that's
         * being sent to the database and will be cleared upon transaction
         * complete and response parsed.
         *
         * @private
         * @instance
         * @member transaction
         * @summary
         * Active transaction queue to be sent to the database
         * @type {array}
         * @default []
         * @since 3.0.0
         */

    }, {
        key: "transaction",
        get: function get() {
            return this._transaction;
        },
        set: function set(value) {
            if (Array.isArray(value)) this._transaction = value;else this._transaction = [];

            this.nextInQueue();
        }

        /**
         * The class to use for neo4j-query-object, it must either be
         * the neo4j-query-object class or a subclass of it.
         *
         * @protected
         * @instance
         * @member QueryObjectClass
         * @type {array}
         * @default []
         * @since 4.1.3
         */

    }, {
        key: "QueryObjectClass",
        get: function get() {
            return this._QueryObjectClass;
        },
        set: function set(value) {
            if (value instanceof _neo4jQueryObject2.default) this._QueryObjectClass = value;else this._QueryObjectClass = _neo4jQueryObject2.default;
        }
    }]);
    return SimpleNeo4J;
})();

/**
 * Cypher toolbelt
 *
 * @public
 * @static
 * @member tools
 * @type {module:cypher-tools}
 * @since 3.3.0
 */
module.exports.tools = _cypherTools2.default;