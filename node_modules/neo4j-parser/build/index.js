"use strict";

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module neo4j-parser
 * @requires {@link https://www.npmjs.com/package/lodash|lodash}
 */

/**
 * Parsed Result Object
 *
 * This won't be defined at all if an error occured
 *
 * @typedef {object} module:neo4j-parser~parsedResultObj
 * @property {object} [result] -
 * The complete parsed response for this query if raw mode is disabled
 * @property {object} rawResult -
 * The JSON object for this query in object form but unparsed, the object is
 * strcutured exactly how the database sent it back
 * @property {string} rawBody -
 * The raw / unparsed JSON result
 * @property {object} [firstColumn] -
 * The first parsed column of the result if raw mode is disabled
 * @property {object} [firstValue] -
 * The first parsed value of the first parsed column if raw mode is disabled
 */

/**
 * Simple callback, this cb is called once for each query to question whether
 * or not raw mode should be enabled for it individually. returning a truthy
 * value will enable raw mode for this query only, falsy value will not issue
 * raw mode. If raw mode is globally enabled then it always takes presedence
 * and this cb won't be called.
 *
 * @callback module:neo4j-parser~isRawCb
 * @param {number} index -
 * Query index in question
 */

/**
 * Callback for parse progress including errors, explicitly returning false
 * will end the parsing early nytime its called except for errors in which case
 * its already ended.
 *
 * @callback module:neo4j-parser~parserCb
 * @param {any} [error] -
 * Any error that may crop up including query errors. Its worth noting that with
 * query errors, theres no way to know which query caused the error, so any of
 * the queries could be at fault.
 *
 * The parsing has halted at this point.
 *
 * @param {number} [index] -
 * The query index which matches the index sent to the database, if an error
 * occurs this will not be defined
 * @param {module:neo4j-parser~parsedResultObj} [parseObj] -
 * The parsed object based on parameters given and end query, if an error
 * occurs this will not be defined
 */

/**
 * @typedef {object} module:neo4j-parser~parserConfigObj
 * @property {string} body -
 * The JSON Rest API result
 * @property {module:neo4j-parser~parserCb} [cb=function(){}] -
 * The callback which will be called several times on errors and parse progression
 * @property {boolean} [raw=false] -
 * Global raw mode, all queries will skip parsing and essentially just breakdown
 * the json query to an object issuing the cb for each query with its part of the
 * json object
 * @property {module:neo4j-parser~isRawCb} [isRaw=() => {}] -
 * Cb for determining whether an individual query should be processed as raw mode
 */

/**
 * Return codes for the parser
 * @enum {number}
 * @static
 * @readonly
 */
var RETURN_CODES = {
    /**
     * The parsing went smoothly without any errors or being manually halted
     */
    SUCCESS: 0,

    /**
     * An error occured during processing, most likely due to the database declaring
     * a transaction error but could also be a communication error or some other
     * error
     */
    ERROR: 1,

    /**
     * The parsing was stopped mnaually/programatically by returning false
     */
    MANUAL_STOP: 2
};

/**
* This function takes a Neo4J reply from the restful service, parses it, and
* sends back the parsed data either in parsed form mentioned below or raw form.
*
* The response is parsed into a native javascript object that's a bit
* easier and more intuitive than how other similar libraries will parse.
* The object contains 1 key for each returned column, each of those keys
* contains another object which contains all the returned values under that
* column. If the values are a key/value pair their inserted as-is. If its
* another type their inserted under an incrementing index number.
*
* In the case of key/value pairs where multiple keys of the same name exist
* the newer keys will be suffixed with an incrementing number.
*
*     {
*         column1:
*         {
*             key: value,
*             key2: value2,
*             0: `sring`,
*             1: [Array]
*         },
*
*         column2:
*         {
*             key: value
*         }
*     }
*
* @function module:neo4j-parser
* @author {@link http://codepen.io/wiseguy12851|John Mothershed}
* @copyright 2015 John Mothershed
* @license {@link http://www.apache.org/licenses/LICENSE-2.0|Apache-2.0}
* @version 1.0.0
* @summary
* Parse a Neo4J RestAPI JSON response
* @param {module:neo4j-parser~parserConfigObj} opts -
* Options to configure parser
* @return {module:neo4j-parser.RETURN_CODES}
*/
/*
    Copyright 2015 John Mothershed

    Licensed under the Apache License, Version 2.0 (the `License`);
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an `AS IS` BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 */

module.exports = function (opts) {
    // Perform correct type checking
    if (typeof opts !== "object" || opts === null) return RETURN_CODES.ERROR;

    // Pull in variables from configuration object
    var body = opts.body;

    var cb = opts.cb,
        raw = opts.raw,
        isRaw = opts.isRaw;

    // Ensure variables are correct, providing defaults or returning where
    // nesasary

    // body check is handled further down
    if (typeof cb !== "function") cb = function () {};
    if (typeof raw !== "boolean") raw = false;
    if (typeof isRaw !== "function") isRaw = function () {};

    /*
     * This is the format of body, its a bit complicated and needs to be
     * transformed into a simpler object:
     *
     * {
     * 		results:
     * 		[
     * 			{ // statement # matching query #
     *
     * 				columns: [column names...],
     * 				data:
     * 				[ // array of row data-sets,
     * 				  // think multiple spreadhseets under same name
     * 				  // or groups of rows under same column
     *
     * 					{
     * 						row:
     * 						[ // Array of columns row data
     * 						  // The column number above matches row index here
     *
     *							row object/array/or other
     * 						]
     * 					}
     * 				]
     * 			}
     * 		],
     *
     *		errors: [error strings]
     * }
     */

    // If an active url is specified but its not the Neo4J endpoint url
    // the body may be empty, this is suppose to test and fail if the
    // body is in that state but it doesnt work so far for some reason
    if (!body || body === "" || typeof body !== "string") {
        cb("empty or invalid body received");
        return RETURN_CODES.ERROR;
    }

    // Parse body and get results object
    var dbResponse = JSON.parse(body),
        results = dbResponse.results;

    // Now check for errors that happened within the db
    if (dbResponse.errors.length > 0) {
        // Report and quit
        cb(dbResponse.errors);
        return RETURN_CODES.ERROR;
    }

    /*
     * By this point everythings in the clear, communication happened
     * fine and no transaction errors.
     */

    // Lets loop through each query in the transaction

    var _loop = function _loop(i) {

        /*
         * The plan:
         * Map each column to key in object
         * Map all rows under appropriate column key name in its own object
         * under its own key name or index for non key/value pairs
         */

        var result = results[i],
            // The returned result
        columns = result.columns,
            // All the columns in the result
        ret = {},
            // the fully parsed object after parsing
        rowData = result.data,
            unnamedIndexCols = []; // All the raw, unparsed rows in the result

        var firstValue = undefined,
            // First parsed value in first column
        firstColumn = undefined; // First parsed column

        // Check for raw enabled, if it is, skip the parsing all-together
        if (raw || isRaw(i)) {
            var _end = cb(undefined, // Error
            i, // Query Object number
            {
                result: undefined,
                rawResult: result,
                rawBody: body,
                firstColumn: undefined,
                firstValue: undefined
            });

            if (_end === false) return {
                    v: RETURN_CODES.MANUAL_STOP
                };
            return "continue";
        }

        // Add in the columns
        for (var j = 0; j < columns.length; j++) {
            var column = columns[j];
            ret[column] = {};
        }

        // Now move onto row datasets
        for (var j = 0; j < rowData.length; j++) {

            // Get the row dataset from datasets
            var rowDataset = rowData[j].row;

            // Go through the elements of the dataset
            // Each element in the dataset corresponds
            // to a column number, and its data can be
            // an object or some other type
            // (number, string, etc...)

            var _loop2 = function _loop2(k) {

                // Get the dataset element
                var rowDatasetElement = rowDataset[k];

                // Initialize unnamed index to 0 for the current column
                // if not already Initialized
                if (unnamedIndexCols[k] === undefined) unnamedIndexCols[k] = 0;

                // If its not an object create a key with unnamed index
                // value and place the value under it
                if (typeof rowDatasetElement !== "object" || rowDatasetElement === null) {
                    if (firstValue === undefined) firstValue = rowDatasetElement;
                    ret[columns[k]][unnamedIndexCols[k]] = rowDatasetElement;
                    unnamedIndexCols[k]++;
                }

                // If it is an object make sure its not an array, arrays
                // get the same treatment as above. Objects get merged
                // with main object.

                // In the end there is one object per column and under
                // each column there is a key/value pair from all rows
                // and row-sets for that column
                else {
                        if (rowDatasetElement.length !== undefined) {
                            if (firstValue === undefined) firstValue = rowDatasetElement;
                            ret[columns[k]][unnamedIndexCols[k]] = rowDatasetElement;
                            unnamedIndexCols[k]++;
                        } else {
                            // The element is an object, merge all key/value
                            // pairs with the column object but ensure key
                            // names don't overwrite any existing key names
                            _lodash2.default.forOwn(rowDatasetElement, function (value, key) {

                                // Get column object
                                var columnObj = ret[columns[k]];

                                if (firstValue === undefined) firstValue = value;

                                // If key doesnt exist, place there
                                if (columnObj[key] === undefined) columnObj[key] = value;

                                // Rename the key with a number suffix, find
                                // a number suffix that will make the key
                                // unique
                                else {
                                        // Number suffix
                                        var newIndex = 0;

                                        // Loop through until an available
                                        // number suffix exists
                                        while (true) {
                                            // Prepare new key name
                                            var newKeyName = "" + key + newIndex;
                                            newIndex++;

                                            // If it makes the key unique then
                                            // use it and break out of loop
                                            if (columnObj[newKeyName] === undefined) {
                                                columnObj[newKeyName] = value;
                                                break;
                                            }
                                        }
                                    }
                            }, undefined);
                        }
                    }
            };

            for (var k = 0; k < rowDataset.length; k++) {
                _loop2(k);
            }
        }

        firstColumn = ret[columns[0]];

        var end = cb(undefined, i, {
            result: ret,
            rawResult: result,
            rawBody: body,
            firstColumn: firstColumn,
            firstValue: firstValue
        });

        if (end === false) return {
                v: RETURN_CODES.MANUAL_STOP
            };
    };

    for (var i = 0; i < results.length; i++) {
        var _ret = _loop(i);

        switch (_ret) {
            case "continue":
                continue;

            default:
                if ((typeof _ret === "undefined" ? "undefined" : (0, _typeof3.default)(_ret)) === "object") return _ret.v;
        }
    }

    return RETURN_CODES.SUCCESS;
};

module.exports.RETURN_CODES = RETURN_CODES;